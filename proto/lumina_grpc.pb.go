// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v5.29.3
// source: proto/lumina.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Lumina_ListByDate_FullMethodName          = "/lumina.Lumina/ListByDate"
	Lumina_Delete_FullMethodName              = "/lumina.Lumina/Delete"
	Lumina_FilterNotUploaded_FullMethodName   = "/lumina.Lumina/FilterNotUploaded"
	Lumina_SetDriveSMB_FullMethodName         = "/lumina.Lumina/SetDriveSMB"
	Lumina_ListDriveSMBShares_FullMethodName  = "/lumina.Lumina/ListDriveSMBShares"
	Lumina_ListDriveSMBDir_FullMethodName     = "/lumina.Lumina/ListDriveSMBDir"
	Lumina_SetDriveSMBShare_FullMethodName    = "/lumina.Lumina/SetDriveSMBShare"
	Lumina_SetDriveWebdav_FullMethodName      = "/lumina.Lumina/SetDriveWebdav"
	Lumina_ListDriveWebdavDir_FullMethodName  = "/lumina.Lumina/ListDriveWebdavDir"
	Lumina_SetDriveNFS_FullMethodName         = "/lumina.Lumina/SetDriveNFS"
	Lumina_ListDriveNFSDir_FullMethodName     = "/lumina.Lumina/ListDriveNFSDir"
	Lumina_SetDriveS3_FullMethodName          = "/lumina.Lumina/SetDriveS3"
	Lumina_ListDriveS3Buckets_FullMethodName  = "/lumina.Lumina/ListDriveS3Buckets"
	Lumina_MoveToTrash_FullMethodName         = "/lumina.Lumina/MoveToTrash"
	Lumina_ListTrash_FullMethodName           = "/lumina.Lumina/ListTrash"
	Lumina_RestoreFromTrash_FullMethodName    = "/lumina.Lumina/RestoreFromTrash"
	Lumina_EmptyTrash_FullMethodName          = "/lumina.Lumina/EmptyTrash"
	Lumina_MoveToLocked_FullMethodName        = "/lumina.Lumina/MoveToLocked"
	Lumina_ListLocked_FullMethodName          = "/lumina.Lumina/ListLocked"
	Lumina_RestoreFromLocked_FullMethodName   = "/lumina.Lumina/RestoreFromLocked"
	Lumina_RebuildIndex_FullMethodName        = "/lumina.Lumina/RebuildIndex"
	Lumina_GetIndexStats_FullMethodName       = "/lumina.Lumina/GetIndexStats"
	Lumina_ClearThumbnailCache_FullMethodName = "/lumina.Lumina/ClearThumbnailCache"
	Lumina_UpdatePhotoLabels_FullMethodName   = "/lumina.Lumina/UpdatePhotoLabels"
	Lumina_SearchPhotos_FullMethodName        = "/lumina.Lumina/SearchPhotos"
	Lumina_GetUnlabeledPhotos_FullMethodName  = "/lumina.Lumina/GetUnlabeledPhotos"
	Lumina_GetLabelSummary_FullMethodName     = "/lumina.Lumina/GetLabelSummary"
)

// LuminaClient is the client API for Lumina service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LuminaClient interface {
	ListByDate(ctx context.Context, in *ListByDateRequest, opts ...grpc.CallOption) (*ListByDateResponse, error)
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	FilterNotUploaded(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[FilterNotUploadedRequest, FilterNotUploadedResponse], error)
	// SAMBA Drive
	SetDriveSMB(ctx context.Context, in *SetDriveSMBRequest, opts ...grpc.CallOption) (*SetDriveSMBResponse, error)
	ListDriveSMBShares(ctx context.Context, in *ListDriveSMBSharesRequest, opts ...grpc.CallOption) (*ListDriveSMBSharesResponse, error)
	ListDriveSMBDir(ctx context.Context, in *ListDriveSMBDirRequest, opts ...grpc.CallOption) (*ListDriveSMBDirResponse, error)
	SetDriveSMBShare(ctx context.Context, in *SetDriveSMBShareRequest, opts ...grpc.CallOption) (*SetDriveSMBShareResponse, error)
	// Webdav Drive
	SetDriveWebdav(ctx context.Context, in *SetDriveWebdavRequest, opts ...grpc.CallOption) (*SetDriveWebdavResponse, error)
	ListDriveWebdavDir(ctx context.Context, in *ListDriveWebdavDirRequest, opts ...grpc.CallOption) (*ListDriveWebdavDirResponse, error)
	// NFS Drive
	SetDriveNFS(ctx context.Context, in *SetDriveNFSRequest, opts ...grpc.CallOption) (*SetDriveNFSResponse, error)
	ListDriveNFSDir(ctx context.Context, in *ListDriveNFSDirRequest, opts ...grpc.CallOption) (*ListDriveNFSDirResponse, error)
	// S3 Compatible Drive
	SetDriveS3(ctx context.Context, in *SetDriveS3Request, opts ...grpc.CallOption) (*SetDriveS3Response, error)
	ListDriveS3Buckets(ctx context.Context, in *ListDriveS3BucketsRequest, opts ...grpc.CallOption) (*ListDriveS3BucketsResponse, error)
	// Trash
	MoveToTrash(ctx context.Context, in *MoveToTrashRequest, opts ...grpc.CallOption) (*MoveToTrashResponse, error)
	ListTrash(ctx context.Context, in *ListTrashRequest, opts ...grpc.CallOption) (*ListTrashResponse, error)
	RestoreFromTrash(ctx context.Context, in *RestoreFromTrashRequest, opts ...grpc.CallOption) (*RestoreFromTrashResponse, error)
	EmptyTrash(ctx context.Context, in *EmptyTrashRequest, opts ...grpc.CallOption) (*EmptyTrashResponse, error)
	// Locked folder
	MoveToLocked(ctx context.Context, in *MoveToLockedRequest, opts ...grpc.CallOption) (*MoveToLockedResponse, error)
	ListLocked(ctx context.Context, in *ListLockedRequest, opts ...grpc.CallOption) (*ListLockedResponse, error)
	RestoreFromLocked(ctx context.Context, in *RestoreFromLockedRequest, opts ...grpc.CallOption) (*RestoreFromLockedResponse, error)
	// Index management
	RebuildIndex(ctx context.Context, in *RebuildIndexRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RebuildIndexResponse], error)
	GetIndexStats(ctx context.Context, in *GetIndexStatsRequest, opts ...grpc.CallOption) (*GetIndexStatsResponse, error)
	ClearThumbnailCache(ctx context.Context, in *ClearThumbnailCacheRequest, opts ...grpc.CallOption) (*ClearThumbnailCacheResponse, error)
	// ML Photo Search
	UpdatePhotoLabels(ctx context.Context, in *UpdatePhotoLabelsRequest, opts ...grpc.CallOption) (*UpdatePhotoLabelsResponse, error)
	SearchPhotos(ctx context.Context, in *SearchPhotosRequest, opts ...grpc.CallOption) (*SearchPhotosResponse, error)
	GetUnlabeledPhotos(ctx context.Context, in *GetUnlabeledPhotosRequest, opts ...grpc.CallOption) (*GetUnlabeledPhotosResponse, error)
	GetLabelSummary(ctx context.Context, in *GetLabelSummaryRequest, opts ...grpc.CallOption) (*GetLabelSummaryResponse, error)
}

type luminaClient struct {
	cc grpc.ClientConnInterface
}

func NewLuminaClient(cc grpc.ClientConnInterface) LuminaClient {
	return &luminaClient{cc}
}

func (c *luminaClient) ListByDate(ctx context.Context, in *ListByDateRequest, opts ...grpc.CallOption) (*ListByDateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListByDateResponse)
	err := c.cc.Invoke(ctx, Lumina_ListByDate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, Lumina_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) FilterNotUploaded(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[FilterNotUploadedRequest, FilterNotUploadedResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lumina_ServiceDesc.Streams[0], Lumina_FilterNotUploaded_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[FilterNotUploadedRequest, FilterNotUploadedResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lumina_FilterNotUploadedClient = grpc.BidiStreamingClient[FilterNotUploadedRequest, FilterNotUploadedResponse]

func (c *luminaClient) SetDriveSMB(ctx context.Context, in *SetDriveSMBRequest, opts ...grpc.CallOption) (*SetDriveSMBResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetDriveSMBResponse)
	err := c.cc.Invoke(ctx, Lumina_SetDriveSMB_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) ListDriveSMBShares(ctx context.Context, in *ListDriveSMBSharesRequest, opts ...grpc.CallOption) (*ListDriveSMBSharesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDriveSMBSharesResponse)
	err := c.cc.Invoke(ctx, Lumina_ListDriveSMBShares_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) ListDriveSMBDir(ctx context.Context, in *ListDriveSMBDirRequest, opts ...grpc.CallOption) (*ListDriveSMBDirResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDriveSMBDirResponse)
	err := c.cc.Invoke(ctx, Lumina_ListDriveSMBDir_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) SetDriveSMBShare(ctx context.Context, in *SetDriveSMBShareRequest, opts ...grpc.CallOption) (*SetDriveSMBShareResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetDriveSMBShareResponse)
	err := c.cc.Invoke(ctx, Lumina_SetDriveSMBShare_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) SetDriveWebdav(ctx context.Context, in *SetDriveWebdavRequest, opts ...grpc.CallOption) (*SetDriveWebdavResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetDriveWebdavResponse)
	err := c.cc.Invoke(ctx, Lumina_SetDriveWebdav_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) ListDriveWebdavDir(ctx context.Context, in *ListDriveWebdavDirRequest, opts ...grpc.CallOption) (*ListDriveWebdavDirResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDriveWebdavDirResponse)
	err := c.cc.Invoke(ctx, Lumina_ListDriveWebdavDir_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) SetDriveNFS(ctx context.Context, in *SetDriveNFSRequest, opts ...grpc.CallOption) (*SetDriveNFSResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetDriveNFSResponse)
	err := c.cc.Invoke(ctx, Lumina_SetDriveNFS_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) ListDriveNFSDir(ctx context.Context, in *ListDriveNFSDirRequest, opts ...grpc.CallOption) (*ListDriveNFSDirResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDriveNFSDirResponse)
	err := c.cc.Invoke(ctx, Lumina_ListDriveNFSDir_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) SetDriveS3(ctx context.Context, in *SetDriveS3Request, opts ...grpc.CallOption) (*SetDriveS3Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetDriveS3Response)
	err := c.cc.Invoke(ctx, Lumina_SetDriveS3_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) ListDriveS3Buckets(ctx context.Context, in *ListDriveS3BucketsRequest, opts ...grpc.CallOption) (*ListDriveS3BucketsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDriveS3BucketsResponse)
	err := c.cc.Invoke(ctx, Lumina_ListDriveS3Buckets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) MoveToTrash(ctx context.Context, in *MoveToTrashRequest, opts ...grpc.CallOption) (*MoveToTrashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MoveToTrashResponse)
	err := c.cc.Invoke(ctx, Lumina_MoveToTrash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) ListTrash(ctx context.Context, in *ListTrashRequest, opts ...grpc.CallOption) (*ListTrashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTrashResponse)
	err := c.cc.Invoke(ctx, Lumina_ListTrash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) RestoreFromTrash(ctx context.Context, in *RestoreFromTrashRequest, opts ...grpc.CallOption) (*RestoreFromTrashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RestoreFromTrashResponse)
	err := c.cc.Invoke(ctx, Lumina_RestoreFromTrash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) EmptyTrash(ctx context.Context, in *EmptyTrashRequest, opts ...grpc.CallOption) (*EmptyTrashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EmptyTrashResponse)
	err := c.cc.Invoke(ctx, Lumina_EmptyTrash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) MoveToLocked(ctx context.Context, in *MoveToLockedRequest, opts ...grpc.CallOption) (*MoveToLockedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MoveToLockedResponse)
	err := c.cc.Invoke(ctx, Lumina_MoveToLocked_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) ListLocked(ctx context.Context, in *ListLockedRequest, opts ...grpc.CallOption) (*ListLockedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLockedResponse)
	err := c.cc.Invoke(ctx, Lumina_ListLocked_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) RestoreFromLocked(ctx context.Context, in *RestoreFromLockedRequest, opts ...grpc.CallOption) (*RestoreFromLockedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RestoreFromLockedResponse)
	err := c.cc.Invoke(ctx, Lumina_RestoreFromLocked_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) RebuildIndex(ctx context.Context, in *RebuildIndexRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RebuildIndexResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Lumina_ServiceDesc.Streams[1], Lumina_RebuildIndex_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RebuildIndexRequest, RebuildIndexResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lumina_RebuildIndexClient = grpc.ServerStreamingClient[RebuildIndexResponse]

func (c *luminaClient) GetIndexStats(ctx context.Context, in *GetIndexStatsRequest, opts ...grpc.CallOption) (*GetIndexStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetIndexStatsResponse)
	err := c.cc.Invoke(ctx, Lumina_GetIndexStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) ClearThumbnailCache(ctx context.Context, in *ClearThumbnailCacheRequest, opts ...grpc.CallOption) (*ClearThumbnailCacheResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearThumbnailCacheResponse)
	err := c.cc.Invoke(ctx, Lumina_ClearThumbnailCache_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) UpdatePhotoLabels(ctx context.Context, in *UpdatePhotoLabelsRequest, opts ...grpc.CallOption) (*UpdatePhotoLabelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePhotoLabelsResponse)
	err := c.cc.Invoke(ctx, Lumina_UpdatePhotoLabels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) SearchPhotos(ctx context.Context, in *SearchPhotosRequest, opts ...grpc.CallOption) (*SearchPhotosResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchPhotosResponse)
	err := c.cc.Invoke(ctx, Lumina_SearchPhotos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) GetUnlabeledPhotos(ctx context.Context, in *GetUnlabeledPhotosRequest, opts ...grpc.CallOption) (*GetUnlabeledPhotosResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUnlabeledPhotosResponse)
	err := c.cc.Invoke(ctx, Lumina_GetUnlabeledPhotos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *luminaClient) GetLabelSummary(ctx context.Context, in *GetLabelSummaryRequest, opts ...grpc.CallOption) (*GetLabelSummaryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLabelSummaryResponse)
	err := c.cc.Invoke(ctx, Lumina_GetLabelSummary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LuminaServer is the server API for Lumina service.
// All implementations must embed UnimplementedLuminaServer
// for forward compatibility.
type LuminaServer interface {
	ListByDate(context.Context, *ListByDateRequest) (*ListByDateResponse, error)
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	FilterNotUploaded(grpc.BidiStreamingServer[FilterNotUploadedRequest, FilterNotUploadedResponse]) error
	// SAMBA Drive
	SetDriveSMB(context.Context, *SetDriveSMBRequest) (*SetDriveSMBResponse, error)
	ListDriveSMBShares(context.Context, *ListDriveSMBSharesRequest) (*ListDriveSMBSharesResponse, error)
	ListDriveSMBDir(context.Context, *ListDriveSMBDirRequest) (*ListDriveSMBDirResponse, error)
	SetDriveSMBShare(context.Context, *SetDriveSMBShareRequest) (*SetDriveSMBShareResponse, error)
	// Webdav Drive
	SetDriveWebdav(context.Context, *SetDriveWebdavRequest) (*SetDriveWebdavResponse, error)
	ListDriveWebdavDir(context.Context, *ListDriveWebdavDirRequest) (*ListDriveWebdavDirResponse, error)
	// NFS Drive
	SetDriveNFS(context.Context, *SetDriveNFSRequest) (*SetDriveNFSResponse, error)
	ListDriveNFSDir(context.Context, *ListDriveNFSDirRequest) (*ListDriveNFSDirResponse, error)
	// S3 Compatible Drive
	SetDriveS3(context.Context, *SetDriveS3Request) (*SetDriveS3Response, error)
	ListDriveS3Buckets(context.Context, *ListDriveS3BucketsRequest) (*ListDriveS3BucketsResponse, error)
	// Trash
	MoveToTrash(context.Context, *MoveToTrashRequest) (*MoveToTrashResponse, error)
	ListTrash(context.Context, *ListTrashRequest) (*ListTrashResponse, error)
	RestoreFromTrash(context.Context, *RestoreFromTrashRequest) (*RestoreFromTrashResponse, error)
	EmptyTrash(context.Context, *EmptyTrashRequest) (*EmptyTrashResponse, error)
	// Locked folder
	MoveToLocked(context.Context, *MoveToLockedRequest) (*MoveToLockedResponse, error)
	ListLocked(context.Context, *ListLockedRequest) (*ListLockedResponse, error)
	RestoreFromLocked(context.Context, *RestoreFromLockedRequest) (*RestoreFromLockedResponse, error)
	// Index management
	RebuildIndex(*RebuildIndexRequest, grpc.ServerStreamingServer[RebuildIndexResponse]) error
	GetIndexStats(context.Context, *GetIndexStatsRequest) (*GetIndexStatsResponse, error)
	ClearThumbnailCache(context.Context, *ClearThumbnailCacheRequest) (*ClearThumbnailCacheResponse, error)
	// ML Photo Search
	UpdatePhotoLabels(context.Context, *UpdatePhotoLabelsRequest) (*UpdatePhotoLabelsResponse, error)
	SearchPhotos(context.Context, *SearchPhotosRequest) (*SearchPhotosResponse, error)
	GetUnlabeledPhotos(context.Context, *GetUnlabeledPhotosRequest) (*GetUnlabeledPhotosResponse, error)
	GetLabelSummary(context.Context, *GetLabelSummaryRequest) (*GetLabelSummaryResponse, error)
	mustEmbedUnimplementedLuminaServer()
}

// UnimplementedLuminaServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLuminaServer struct{}

func (UnimplementedLuminaServer) ListByDate(context.Context, *ListByDateRequest) (*ListByDateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListByDate not implemented")
}
func (UnimplementedLuminaServer) Delete(context.Context, *DeleteRequest) (*DeleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedLuminaServer) FilterNotUploaded(grpc.BidiStreamingServer[FilterNotUploadedRequest, FilterNotUploadedResponse]) error {
	return status.Error(codes.Unimplemented, "method FilterNotUploaded not implemented")
}
func (UnimplementedLuminaServer) SetDriveSMB(context.Context, *SetDriveSMBRequest) (*SetDriveSMBResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetDriveSMB not implemented")
}
func (UnimplementedLuminaServer) ListDriveSMBShares(context.Context, *ListDriveSMBSharesRequest) (*ListDriveSMBSharesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDriveSMBShares not implemented")
}
func (UnimplementedLuminaServer) ListDriveSMBDir(context.Context, *ListDriveSMBDirRequest) (*ListDriveSMBDirResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDriveSMBDir not implemented")
}
func (UnimplementedLuminaServer) SetDriveSMBShare(context.Context, *SetDriveSMBShareRequest) (*SetDriveSMBShareResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetDriveSMBShare not implemented")
}
func (UnimplementedLuminaServer) SetDriveWebdav(context.Context, *SetDriveWebdavRequest) (*SetDriveWebdavResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetDriveWebdav not implemented")
}
func (UnimplementedLuminaServer) ListDriveWebdavDir(context.Context, *ListDriveWebdavDirRequest) (*ListDriveWebdavDirResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDriveWebdavDir not implemented")
}
func (UnimplementedLuminaServer) SetDriveNFS(context.Context, *SetDriveNFSRequest) (*SetDriveNFSResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetDriveNFS not implemented")
}
func (UnimplementedLuminaServer) ListDriveNFSDir(context.Context, *ListDriveNFSDirRequest) (*ListDriveNFSDirResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDriveNFSDir not implemented")
}
func (UnimplementedLuminaServer) SetDriveS3(context.Context, *SetDriveS3Request) (*SetDriveS3Response, error) {
	return nil, status.Error(codes.Unimplemented, "method SetDriveS3 not implemented")
}
func (UnimplementedLuminaServer) ListDriveS3Buckets(context.Context, *ListDriveS3BucketsRequest) (*ListDriveS3BucketsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDriveS3Buckets not implemented")
}
func (UnimplementedLuminaServer) MoveToTrash(context.Context, *MoveToTrashRequest) (*MoveToTrashResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MoveToTrash not implemented")
}
func (UnimplementedLuminaServer) ListTrash(context.Context, *ListTrashRequest) (*ListTrashResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTrash not implemented")
}
func (UnimplementedLuminaServer) RestoreFromTrash(context.Context, *RestoreFromTrashRequest) (*RestoreFromTrashResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RestoreFromTrash not implemented")
}
func (UnimplementedLuminaServer) EmptyTrash(context.Context, *EmptyTrashRequest) (*EmptyTrashResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EmptyTrash not implemented")
}
func (UnimplementedLuminaServer) MoveToLocked(context.Context, *MoveToLockedRequest) (*MoveToLockedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MoveToLocked not implemented")
}
func (UnimplementedLuminaServer) ListLocked(context.Context, *ListLockedRequest) (*ListLockedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListLocked not implemented")
}
func (UnimplementedLuminaServer) RestoreFromLocked(context.Context, *RestoreFromLockedRequest) (*RestoreFromLockedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RestoreFromLocked not implemented")
}
func (UnimplementedLuminaServer) RebuildIndex(*RebuildIndexRequest, grpc.ServerStreamingServer[RebuildIndexResponse]) error {
	return status.Error(codes.Unimplemented, "method RebuildIndex not implemented")
}
func (UnimplementedLuminaServer) GetIndexStats(context.Context, *GetIndexStatsRequest) (*GetIndexStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetIndexStats not implemented")
}
func (UnimplementedLuminaServer) ClearThumbnailCache(context.Context, *ClearThumbnailCacheRequest) (*ClearThumbnailCacheResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClearThumbnailCache not implemented")
}
func (UnimplementedLuminaServer) UpdatePhotoLabels(context.Context, *UpdatePhotoLabelsRequest) (*UpdatePhotoLabelsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdatePhotoLabels not implemented")
}
func (UnimplementedLuminaServer) SearchPhotos(context.Context, *SearchPhotosRequest) (*SearchPhotosResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchPhotos not implemented")
}
func (UnimplementedLuminaServer) GetUnlabeledPhotos(context.Context, *GetUnlabeledPhotosRequest) (*GetUnlabeledPhotosResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUnlabeledPhotos not implemented")
}
func (UnimplementedLuminaServer) GetLabelSummary(context.Context, *GetLabelSummaryRequest) (*GetLabelSummaryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLabelSummary not implemented")
}
func (UnimplementedLuminaServer) mustEmbedUnimplementedLuminaServer() {}
func (UnimplementedLuminaServer) testEmbeddedByValue()                {}

// UnsafeLuminaServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LuminaServer will
// result in compilation errors.
type UnsafeLuminaServer interface {
	mustEmbedUnimplementedLuminaServer()
}

func RegisterLuminaServer(s grpc.ServiceRegistrar, srv LuminaServer) {
	// If the following call panics, it indicates UnimplementedLuminaServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Lumina_ServiceDesc, srv)
}

func _Lumina_ListByDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListByDateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).ListByDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_ListByDate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).ListByDate(ctx, req.(*ListByDateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_FilterNotUploaded_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LuminaServer).FilterNotUploaded(&grpc.GenericServerStream[FilterNotUploadedRequest, FilterNotUploadedResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lumina_FilterNotUploadedServer = grpc.BidiStreamingServer[FilterNotUploadedRequest, FilterNotUploadedResponse]

func _Lumina_SetDriveSMB_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDriveSMBRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).SetDriveSMB(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_SetDriveSMB_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).SetDriveSMB(ctx, req.(*SetDriveSMBRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_ListDriveSMBShares_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDriveSMBSharesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).ListDriveSMBShares(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_ListDriveSMBShares_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).ListDriveSMBShares(ctx, req.(*ListDriveSMBSharesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_ListDriveSMBDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDriveSMBDirRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).ListDriveSMBDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_ListDriveSMBDir_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).ListDriveSMBDir(ctx, req.(*ListDriveSMBDirRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_SetDriveSMBShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDriveSMBShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).SetDriveSMBShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_SetDriveSMBShare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).SetDriveSMBShare(ctx, req.(*SetDriveSMBShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_SetDriveWebdav_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDriveWebdavRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).SetDriveWebdav(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_SetDriveWebdav_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).SetDriveWebdav(ctx, req.(*SetDriveWebdavRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_ListDriveWebdavDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDriveWebdavDirRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).ListDriveWebdavDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_ListDriveWebdavDir_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).ListDriveWebdavDir(ctx, req.(*ListDriveWebdavDirRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_SetDriveNFS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDriveNFSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).SetDriveNFS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_SetDriveNFS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).SetDriveNFS(ctx, req.(*SetDriveNFSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_ListDriveNFSDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDriveNFSDirRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).ListDriveNFSDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_ListDriveNFSDir_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).ListDriveNFSDir(ctx, req.(*ListDriveNFSDirRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_SetDriveS3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDriveS3Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).SetDriveS3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_SetDriveS3_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).SetDriveS3(ctx, req.(*SetDriveS3Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_ListDriveS3Buckets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDriveS3BucketsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).ListDriveS3Buckets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_ListDriveS3Buckets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).ListDriveS3Buckets(ctx, req.(*ListDriveS3BucketsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_MoveToTrash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveToTrashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).MoveToTrash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_MoveToTrash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).MoveToTrash(ctx, req.(*MoveToTrashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_ListTrash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTrashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).ListTrash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_ListTrash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).ListTrash(ctx, req.(*ListTrashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_RestoreFromTrash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreFromTrashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).RestoreFromTrash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_RestoreFromTrash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).RestoreFromTrash(ctx, req.(*RestoreFromTrashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_EmptyTrash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyTrashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).EmptyTrash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_EmptyTrash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).EmptyTrash(ctx, req.(*EmptyTrashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_MoveToLocked_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveToLockedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).MoveToLocked(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_MoveToLocked_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).MoveToLocked(ctx, req.(*MoveToLockedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_ListLocked_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLockedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).ListLocked(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_ListLocked_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).ListLocked(ctx, req.(*ListLockedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_RestoreFromLocked_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreFromLockedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).RestoreFromLocked(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_RestoreFromLocked_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).RestoreFromLocked(ctx, req.(*RestoreFromLockedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_RebuildIndex_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RebuildIndexRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LuminaServer).RebuildIndex(m, &grpc.GenericServerStream[RebuildIndexRequest, RebuildIndexResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Lumina_RebuildIndexServer = grpc.ServerStreamingServer[RebuildIndexResponse]

func _Lumina_GetIndexStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIndexStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).GetIndexStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_GetIndexStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).GetIndexStats(ctx, req.(*GetIndexStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_ClearThumbnailCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearThumbnailCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).ClearThumbnailCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_ClearThumbnailCache_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).ClearThumbnailCache(ctx, req.(*ClearThumbnailCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_UpdatePhotoLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePhotoLabelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).UpdatePhotoLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_UpdatePhotoLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).UpdatePhotoLabels(ctx, req.(*UpdatePhotoLabelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_SearchPhotos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchPhotosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).SearchPhotos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_SearchPhotos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).SearchPhotos(ctx, req.(*SearchPhotosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_GetUnlabeledPhotos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUnlabeledPhotosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).GetUnlabeledPhotos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_GetUnlabeledPhotos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).GetUnlabeledPhotos(ctx, req.(*GetUnlabeledPhotosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Lumina_GetLabelSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLabelSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LuminaServer).GetLabelSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Lumina_GetLabelSummary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LuminaServer).GetLabelSummary(ctx, req.(*GetLabelSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Lumina_ServiceDesc is the grpc.ServiceDesc for Lumina service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Lumina_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lumina.Lumina",
	HandlerType: (*LuminaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListByDate",
			Handler:    _Lumina_ListByDate_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Lumina_Delete_Handler,
		},
		{
			MethodName: "SetDriveSMB",
			Handler:    _Lumina_SetDriveSMB_Handler,
		},
		{
			MethodName: "ListDriveSMBShares",
			Handler:    _Lumina_ListDriveSMBShares_Handler,
		},
		{
			MethodName: "ListDriveSMBDir",
			Handler:    _Lumina_ListDriveSMBDir_Handler,
		},
		{
			MethodName: "SetDriveSMBShare",
			Handler:    _Lumina_SetDriveSMBShare_Handler,
		},
		{
			MethodName: "SetDriveWebdav",
			Handler:    _Lumina_SetDriveWebdav_Handler,
		},
		{
			MethodName: "ListDriveWebdavDir",
			Handler:    _Lumina_ListDriveWebdavDir_Handler,
		},
		{
			MethodName: "SetDriveNFS",
			Handler:    _Lumina_SetDriveNFS_Handler,
		},
		{
			MethodName: "ListDriveNFSDir",
			Handler:    _Lumina_ListDriveNFSDir_Handler,
		},
		{
			MethodName: "SetDriveS3",
			Handler:    _Lumina_SetDriveS3_Handler,
		},
		{
			MethodName: "ListDriveS3Buckets",
			Handler:    _Lumina_ListDriveS3Buckets_Handler,
		},
		{
			MethodName: "MoveToTrash",
			Handler:    _Lumina_MoveToTrash_Handler,
		},
		{
			MethodName: "ListTrash",
			Handler:    _Lumina_ListTrash_Handler,
		},
		{
			MethodName: "RestoreFromTrash",
			Handler:    _Lumina_RestoreFromTrash_Handler,
		},
		{
			MethodName: "EmptyTrash",
			Handler:    _Lumina_EmptyTrash_Handler,
		},
		{
			MethodName: "MoveToLocked",
			Handler:    _Lumina_MoveToLocked_Handler,
		},
		{
			MethodName: "ListLocked",
			Handler:    _Lumina_ListLocked_Handler,
		},
		{
			MethodName: "RestoreFromLocked",
			Handler:    _Lumina_RestoreFromLocked_Handler,
		},
		{
			MethodName: "GetIndexStats",
			Handler:    _Lumina_GetIndexStats_Handler,
		},
		{
			MethodName: "ClearThumbnailCache",
			Handler:    _Lumina_ClearThumbnailCache_Handler,
		},
		{
			MethodName: "UpdatePhotoLabels",
			Handler:    _Lumina_UpdatePhotoLabels_Handler,
		},
		{
			MethodName: "SearchPhotos",
			Handler:    _Lumina_SearchPhotos_Handler,
		},
		{
			MethodName: "GetUnlabeledPhotos",
			Handler:    _Lumina_GetUnlabeledPhotos_Handler,
		},
		{
			MethodName: "GetLabelSummary",
			Handler:    _Lumina_GetLabelSummary_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FilterNotUploaded",
			Handler:       _Lumina_FilterNotUploaded_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "RebuildIndex",
			Handler:       _Lumina_RebuildIndex_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/lumina.proto",
}
